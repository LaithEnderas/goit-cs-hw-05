# sorter.py
# async file sorter by extension

import argparse
import asyncio
import logging
import shutil
from pathlib import Path


def setup_logging() -> None:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(message)s",
        handlers=[
            logging.FileHandler("sorter.log", encoding="utf-8"),
            logging.StreamHandler(),
        ],
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="sort files by extension asynchronously")
    parser.add_argument("--source", required=True, help="source folder with files")
    parser.add_argument("--output", required=True, help="output folder for sorted files")
    parser.add_argument("--workers", type=int, default=8, help="number of async workers")
    return parser.parse_args()


def ext_folder(file_path: Path) -> str:
    ext = file_path.suffix.lower().lstrip(".")
    return ext if ext else "no_extension"


def unique_dest_path(dest_dir: Path, filename: str) -> Path:
    candidate = dest_dir / filename
    if not candidate.exists():
        return candidate

    stem = Path(filename).stem
    suffix = Path(filename).suffix
    i = 1
    while True:
        candidate = dest_dir / f"{stem}_{i}{suffix}"
        if not candidate.exists():
            return candidate
        i += 1


async def copy_file(file_path: Path, output_dir: Path) -> None:
    try:
        folder = ext_folder(file_path)
        dest_dir = output_dir / folder
        dest_dir.mkdir(parents=True, exist_ok=True)

        dest_path = unique_dest_path(dest_dir, file_path.name)

        await asyncio.to_thread(shutil.copy2, file_path, dest_path)
        logging.info("copied: %s -> %s", file_path, dest_path)

    except Exception:
        logging.exception("failed to copy: %s", file_path)


async def read_folder(source_dir: Path, queue: asyncio.Queue) -> None:
    # recursively walks source folder and puts files into queue
    try:
        for path in source_dir.rglob("*"):
            if path.is_file():
                await queue.put(path)
    except Exception:
        logging.exception("failed to read folder: %s", source_dir)


async def worker(name: str, queue: asyncio.Queue, output_dir: Path) -> None:
    while True:
        item = await queue.get()
        try:
            if item is None:
                return
            await copy_file(item, output_dir)
        finally:
            queue.task_done()


async def main_async(source: Path, output: Path, workers: int) -> None:
    queue: asyncio.Queue = asyncio.Queue()

    output.mkdir(parents=True, exist_ok=True)

    tasks = [asyncio.create_task(worker(f"w{i}", queue, output)) for i in range(workers)]

    await read_folder(source, queue)

    for _ in range(workers):
        await queue.put(None)

    await queue.join()

    for t in tasks:
        await t


def main() -> None:
    setup_logging()
    args = parse_args()

    source = Path(args.source).expanduser().resolve()
    output = Path(args.output).expanduser().resolve()
    workers = max(1, int(args.workers))

    if not source.exists() or not source.is_dir():
        logging.error("source folder not found: %s", source)
        return

    start = asyncio.get_event_loop_policy().get_event_loop().time() if hasattr(asyncio, "get_event_loop_policy") else None

    t0 = asyncio.get_event_loop().time() if asyncio.get_event_loop().is_running() else None
    # simpler timing
    import time
    t_start = time.perf_counter()

    asyncio.run(main_async(source, output, workers))

    t_end = time.perf_counter()
    logging.info("done in %.6f seconds", t_end - t_start)


if __name__ == "__main__":
    main()
